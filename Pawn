
//THIS IS AN UPDATED VERSION 
package chess2;

public class Pawn extends Piece{
    Piece tagRight;
    Piece tagLeft;
    
    /**
     * This is the pawn object
     * @param boards common Board
     * @param x x coordinate
     * @param y y coordinate
     * @param id piece id
     * @param color color of piece
     */
    public Pawn(Board boards, int x, int y, int id, char color){
        setup(boards, x,y,id,color);//uses base constructor
        setTag(id,"P",color);//tag is just for display mainly, but also used for now, once we have graphics we can transition out
    }    
    
    /**
     * Checks to see if it is a legal move, handled promotion as well as en passant
     * When promotion occurs the tag of the piece changes to reflect the new type it is so based off of this we can run a switch statement to determine 
     * what type of moves we should consider, if it was promoted to a queen look at queen moves, bishop run bishop moves, etc.
     * If there was no promotion then run pawn moves and also look for enpassant which is one of the special cases that was written into pawn 
     * Enpassant works by making sure the movecount is zero, then using the moverecorder arraylist that is built into every piece and creating a variable
     * that we can use for later to make sure that the last piece was the pawn that we want to perform enpassant on 
     * Finally, squares next to the pawn are pawns of the opposite color, and they have the correct Y location, and the movement there was their first move
     * and the last move that was made, enpassant becomes a legal move and we give it a move message(the second parameter in addPossibleMoves()
     * of enpassant so that we can handle it properly 
     */
    public void checkLegalMove(){ 
        switch (tag.charAt(1)) {
            case 'Q':
                queenMoves(false,tag.substring(0,1));
                break;
            case 'H':
                knightMoves(tag.substring(0,1));
                break;
            case 'B':
                bishopMoves(false,tag.substring(0,1));
                break;
            case 'R':
                rookMoves(false,tag.substring(0,1));
                break;
            default:
                pawnMoves();
                String currentMove = "";
                if(totalMoveCount > 0){
                    currentMove = moveRecorder.get(totalMoveCount - 1); //uses arrayList to get current move (move made before this)
                }
                if(tag.charAt(0)=='w'){
                    tagRight = returnPiece(x-1,y);
                    
                    tagLeft = returnPiece(x+1,y);
                    
                    
                    //enpassant to the right
                    if(checkbounds(getX()-1,getY()-1)&&getY()==3&&!boards.isInWhite(getX()-1,getY()-1)&&!boards.isInBlack(getX()-1, getY()-1)){
                        {
                            if(tagRight.getTag().charAt(1)=='P'&&Integer.parseInt(tagRight.getTag().substring(4))==1&&getLastMoveTag().equals(tagRight.getTag().substring(0,4))){
                                addPossibleMoves(getX()-1,getY()-1,"enpassant");
                                // Chess2.boards[getX()+1][getY()] = "00000";
                            }
                        }
                        
                    }
                    //enpassant to the left, not completed
                    if(checkbounds(getX()+1,getY()-1)&&getY()==3&&!boards.isInWhite(getX()+1,getY()-1)&&!boards.isInBlack(getX()+1, getY()-1)){
                        if(tagLeft.getTag().charAt(1)=='P'&&Integer.parseInt(tagLeft.getTag().substring(4))==1&&getLastMoveTag().equals(tagLeft.getTag().substring(0,4))){
                            addPossibleMoves(getX()+1,getY()-1,"enpassant");
                        }
                    }
                }else{
                    tagRight = returnPiece(x-1,y);
                    tagLeft = returnPiece(x+1,y);
                    //enpassant to the right
                    if(checkbounds(getX()-1,getY()+1)&&getY()==4&&!boards.isInBlack(getX()-1,getY()+1)&&!boards.isInWhite(getX()-1, getY()+1)){
                        {
                            if(tagRight.getTag().charAt(1)=='P'&&Integer.parseInt(tagRight.getTag().substring(4))==1&&getLastMoveTag().equals(tagRight.getTag().substring(0,4))){
                                
                                
                                addPossibleMoves(getX()-1,getY()+1,"enpassant");
                                // Chess2.boards[getX()+1][getY()] = "00000";
                            }
                        }
                        
                    }
                    //enpassant to the left, not completed
                    if(checkbounds(getX()+1,getY()-1)&&getY()==4&&!boards.isInWhite(getX()+1,getY()+1)&&!boards.isInBlack(getX()+1, getY()+1)){
                        if(tagLeft.getTag().charAt(1)=='P'&&Integer.parseInt(tagLeft.getTag().substring(4))==1&&getLastMoveTag().equals(tagLeft.getTag().substring(0,4))){
                            addPossibleMoves(getX()+1,getY()+1,"enpassant");
                        }
                    }
                }   break; 
        }
    }
}

