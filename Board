
//THIS IS AN UPDATED VERSION 
package chess2;

import java.util.ArrayList;
/**
 * The purpose of Board is to create an internal array that all movemeents can be managed on and every class can access and use 
 Board allows us to test moves and can be refreshed with the display Board any time it becoems corrupted or we want to refresh it to run other 
 tests 
 Board also has native methods that piece and other classes can use and we are working on adding a moveRecorder here so that we can have one 
 moveRecorder class instead of one for every piece which creates complication 
 */

public class Board {
    String[][] board = new String[8][8];//the Board is stored as an array, this array can be flipped, and is generated in chess, the weird array in the beginning
    //side note about these, coordinates will be stored from 
    ArrayList<int[]> whiteMoveLocations = new ArrayList<>();//can store the x and y coordinates of every white piece and its id
    ArrayList<int[]> blackMoveLocations = new ArrayList<>();//stores the x and y coordinates for every black piece and its id
    ArrayList<int[]> whiteLocations = new ArrayList<int[]>();//can store the x and y coordinates of every white piece and its id
    ArrayList<int[]> blackLocations = new ArrayList<int[]>();//stores the x and y coordinates for every black piece and its id
    ArrayList<String> moveRecorder = new ArrayList<String>();
    int whitecount = 0;//for ai later maybe 
    int blackcount = 0; 
    int totalMovecount =0;
    boolean whiteking = true;//used to check if the king is alive
    boolean blackking = true;//used to check if the king is alive
    /**
     * 
     * @param boards the board array, or the public board is initiated using another array, this allows for creation from files 
     */
    public Board(String[][] boards){//sets up the boards based on an array in chess, the one with alread defined values
        for(int i =0; i < 8; i++){
            for(int j=0; j < 8; j++){
                board[i][j] = boards[i][j];
            }
        }
        
    }
    /**
     * Here we add all of the last moves that were made to the move recorder array list 
     * @param move gets the tag of the last move that was made 
     */
    public void moveRecorderAdd(String move){
        moveRecorder.add(move);
    }
    /**
     * 
     * @return returns moveRecorder(the array list storing the tags of all the last moves made)
     */
    public ArrayList<String> getMoveRecorder(){//updated wiht a move recoder 
        return this.moveRecorder;
    }
    
    /**
     * any changes made to the array in Board are reflected here by updating the Board to the array that is in chess 
     * @param boards This is the common Board
     */
    public void updateBoard(String[][] boards){
        for(int i =0; i < 8; i++){
            for(int j=0; j < 8; j++){
                board[i][j] = boards[i][j];   
            }
        }
    }
    /**
     * The totalMovecount is used to see how many turns have passed and mainly for moves such as castling and enpassant that need to know what the last 
     * move made was etc.
     * @return the totalmovecount 
     */
    public int getTotalMoveCount(){
        return totalMovecount;
    }
    /**
     * increments the total movecount by amount x
     * @param x how much we want to increment the total movecount by  
     */
    public void setTotalMoveCount(int x){
        totalMovecount+=x;
    }
    //returns the public Board so that other classes can acess it 
    public String[][] getBoard(){//used to access the Board in here so if it needs to be updated or used it can be 
        return this.board;
    }
    
    /**
     * Prints out the Board in the output box, this is for testing purposes
     */
    public void displayBoard(){ 
        for(int i =0; i < 8;i++){
            String n = "";
            for(int j =0; j < 8; j++){
                n = n + " " + board[i][j];
            }
            System.out.println(n);
        }
    }
    
    /**
     * Checks to see if there is a black piece in that coordinate
     * @param x x coordinate
     * @param y y coordinate
     * @return returns true if there is a black piece in that square, returns false otherwise
     */
    public boolean isInBlack(int x, int y){
        
        if(board[y][x].charAt(0)=='b'){
            return true;
        }return false;
    }
    
    /**
     * Checks to see if there is a white piece in that coordinate
     * @param x x coordinate
     * @param y y coordinate
     * @return returns true if there is a white piece in that square, returns false otherwise
     */
    public boolean isInWhite(int x, int y){
       
        if(board[y][x].charAt(0)=='w'){//same as is in black but for white 
            return true;
        }return false;
    }
    
    /**
     * checks the amount of white pieces, actually it doesn't now but will in future, and adds the values of each white piece to the ArrayList
     */
    public void getWhiteCount(){
        for(int i =0; i < 8; i++){
            for(int j=0; j<8;j++){
                
            }
        }
    }
    
    /**
     * checks the amount of black pieces, actually it doesn't now but will in future, and adds the values of each black piece to the ArrayList
     */
    public void getBlackCount(){
        for(int i =0; i < 8; i++){
            for(int j=0; j<8;j++){
                
            }
        }
    }

   
    }




//THIS IS AN UPDATED VERSION 
package chess2;

import java.util.ArrayList;
/**
 * The purpose of Board is to create an internal array that all movemeents can be managed on and every class can access and use 
 Board allows us to test moves and can be refreshed with the display Board any time it becoems corrupted or we want to refresh it to run other 
 tests 
 Board also has native methods that piece and other classes can use and we are working on adding a moveRecorder here so that we can have one 
 moveRecorder class instead of one for every piece which creates complication 
 */

public class Board {
    Piece[][] board = new Piece[8][8];//the Board is stored as an array, this array can be flipped, and is generated in chess, the weird array in the beginning
    //side note about these, coordinates will be stored from 
    ArrayList<int[]> whiteMoveLocations = new ArrayList<>();//can store the x and y coordinates of every white piece and its id
    ArrayList<int[]> blackMoveLocations = new ArrayList<>();//stores the x and y coordinates for every black piece and its id
    ArrayList<int[]> whiteLocations = new ArrayList<int[]>();//can store the x and y coordinates of every white piece and its id
    ArrayList<int[]> blackLocations = new ArrayList<int[]>();//stores the x and y coordinates for every black piece and its id
    ArrayList<String> moveRecorder = new ArrayList<String>();
    int whitecount = 0;//for ai later maybe 
    int blackcount = 0; 
    int totalMovecount =0;
    boolean whiteking = true;//used to check if the king is alive
    boolean blackking = true;//used to check if the king is alive
    /**
     * 
     * @param boards the board array, or the public board is initiated using another array, this allows for creation from files 
     */
    public Board(Piece[][] boards){//sets up the boards based on an array in chess, the one with alread defined values
        for(int i =0; i < 8; i++){
            for(int j=0; j < 8; j++){
                board[i][j] = boards[i][j];
            }
        }
        
    }
    /**
     * Here we add all of the last moves that were made to the move recorder array list 
     * @param move gets the tag of the last move that was made 
     */
    public void moveRecorderAdd(String move){
        moveRecorder.add(move);
    }
    /**
     * 
     * @return returns moveRecorder(the array list storing the tags of all the last moves made)
     */
    public ArrayList<String> getMoveRecorder(){//updated wiht a move recoder 
        return this.moveRecorder;
    }
    
    /**
     * any changes made to the array in Board are reflected here by updating the Board to the array that is in chess 
     * @param boards This is the common Board
     */
    public void updateBoard(Piece[][] boards){
        for(int i =0; i < 8; i++){
            for(int j=0; j < 8; j++){
                board[i][j] = boards[i][j];   
            }
        }
    }
    /**
     * The totalMovecount is used to see how many turns have passed and mainly for moves such as castling and enpassant that need to know what the last 
     * move made was etc.
     * @return the totalmovecount 
     */
    public int getTotalMoveCount(){
        return totalMovecount;
    }
    /**
     * increments the total movecount by amount x
     * @param x how much we want to increment the total movecount by  
     */
    public void setTotalMoveCount(int x){
        totalMovecount+=x;
    }
    //returns the public Board so that other classes can acess it 
    public Piece[][] getBoard(){//used to access the Board in here so if it needs to be updated or used it can be 
        return this.board;
    }
    
    /**
     * Prints out the Board in the output box, this is for testing purposes
     */
    public void displayBoard(){ 
        for(int i =0; i < 8;i++){
            String n = "";
            for(int j =0; j < 8; j++){
                n = n + " " + board[i][j].getTag();
            }
            System.out.println(n);
        }
    }
    
    /**
     * Checks to see if there is a black piece in that coordinate
     * @param x x coordinate
     * @param y y coordinate
     * @return returns true if there is a black piece in that square, returns false otherwise
     */
    public boolean isInBlack(int x, int y){
        
        if(board[y][x].getTag().charAt(0)=='b'){
            return true;
        }return false;
    }
    
    /**
     * Checks to see if there is a white piece in that coordinate
     * @param x x coordinate
     * @param y y coordinate
     * @return returns true if there is a white piece in that square, returns false otherwise
     */
    public boolean isInWhite(int x, int y){
       
        if(board[y][x].getTag().charAt(0)=='w'){//same as is in black but for white 
            return true;
        }return false;
    }
    
    /**
     * checks the amount of white pieces, actually it doesn't now but will in future, and adds the values of each white piece to the ArrayList
     */
    public void getWhiteCount(){
        for(int i =0; i < 8; i++){
            for(int j=0; j<8;j++){
                
            }
        }
    }
    
    /**
     * checks the amount of black pieces, actually it doesn't now but will in future, and adds the values of each black piece to the ArrayList
     */
    public void getBlackCount(){
        for(int i =0; i < 8; i++){
            for(int j=0; j<8;j++){
                
            }
        }
    }

   

   
    }








